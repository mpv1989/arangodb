Collections
===========

The preferred way to work with collections in Foxx services is via the [Foxx context](../Reference/Context.md). It provides methods that automatically qualify the collection name with the prefix of the service's mount path to make it unique. This procedure avoids naming conflicts of collection names between different services or multiple installed instances of the same service.

With the method `module.context.collectionName` you can get the prefixed collection name.

```js
module.context.mount === '/hello'
module.context.collectionName('myFoxxCollection') === 'hello_myFoxxCollection'
```

For direct access to the collection, use `module.context.collection`, which behaves exactly like `collectionName` in case of prefixing the collection name.

```js
module.context.collection('myFoxxCollection') === db._collection(module.context.collectionName('myFoxxCollection'))
```

Low-level collection access
---------------------------



Creating collections
--------------------

In order to be able to use a collection from within our service, we should first make sure that the collection actually exists. The right place to create collections your service is going to use is in [a setup script](../Reference/Scripts.md), which Foxx will execute for you when installing or updating the service.

```js
'use strict';
const db = require('@arangodb').db;
const collectionName = module.context.collectionName('myFoxxCollection');

if (!db._collection(collectionName)) {
  db._createDocumentCollection(collectionName);
}
```

Accessing collections
---------------------

We're using the `save` and `document` methods of the collection object to store and retrieve documents in the collection we created in our setup script.

```js
'use sctrict';
const errors = require('@arangodb').errors;
const DOC_NOT_FOUND = errors.ERROR_ARANGO_DOCUMENT_NOT_FOUND.code;
const createRouter = require('@arangodb/foxx/router');
const router = createRouter();
module.context.use(router);

const foxxColl = module.context.collection('myFoxxCollection');

// Store an entry
router.post('/entries', function (req, res) {
  const data = req.body;
  const meta = foxxColl.save(req.body);
  res.send(Object.assign(data, meta));
});

// Retrieve an entry
router.get('/entries/:key', function (req, res) {
  try {
    const data = foxxColl.document(req.pathParams.key);
    res.send(data)
  } catch (e) {
    if (!e.isArangoError || e.errorNum !== DOC_NOT_FOUND) {
      throw e;
    }
    res.throw(404, 'The entry does not exist', e);
  }
});
```

Because the key will be automatically generated by ArangoDB when one wasn't specified in the request body, we're using `Object.assign` to apply the attributes of the metadata object returned by the `save` method to the document before returning it from our route.

The document method returns a document in a collection by its `_key` or `_id`. However when no matching document exists it throws an `ArangoError` exception. Because we want to provide a more descriptive error message than ArangoDB does out of the box, we need to handle that error explicitly.

<!--

# Collections

In Foxx collection names are automatically qualified with a prefix based on the mount path to avoid conflicts between services using identical otherwise collection names (or multiple copies of the same service mounted at different mount paths).

Just use `module.context.collection` bla bla.

## Low-level collection access

When managing collections in your [lifecycle scripts]() bla bla `db._collection`/`db._create`/`db._drop` bla bla `module.context.collectionName` to get the prefixed collection name.

## Sharing collections

While `db._collection` can also be used to share collections between services, bla bla discouraged.

Instead, decide which service should own and manage the collections & expose using `module.exports` and Foxx dependencies to import into other services.

-->