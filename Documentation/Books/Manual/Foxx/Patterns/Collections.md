Working with collections
========================

Prefixed collections
--------------------

Working with `db._collection` and a hardcoded collection name means, multiple copies of the service installed alongside each other in the same database will share the same collection. Because this may not always be what you want, the [Foxx context](../Reference/Context.md) also provides the `collectionName` method which applies a mount point specific prefix to any given collection name to make it unique to the service. It also provides the `collection` method, which behaves almost exactly like `db._collection` except it also applies the prefix before looking the collection up.

**Example**

```js
module.context.mount === '/hello'
module.context.collectionName('myFoxxCollection') === 'hello_myFoxxCollection'
```

Creating collections
--------------------

In order to be able to use a collection from within our service, we should first make sure that the collection actually exists. The right place to create collections your service is going to use is in [a setup script](../Reference/Scripts.md), which Foxx will execute for you when installing or updating the service.

```js
'use strict';
const db = require('@arangodb').db;
const collectionName = module.context.collectionName('myFoxxCollection');

if (!db._collection(collectionName)) {
  db._createDocumentCollection(collectionName);
}
```

Accessing collections
---------------------

We're using the `save` and `document` methods of the collection object to store and retrieve documents in the collection we created in our setup script.

```js
'use sctrict';
const errors = require('@arangodb').errors;
const DOC_NOT_FOUND = errors.ERROR_ARANGO_DOCUMENT_NOT_FOUND.code;
const createRouter = require('@arangodb/foxx/router');
const router = createRouter();
module.context.use(router);

const foxxColl = module.context.collection('myFoxxCollection');

// Store an entry
router.post('/entries', function (req, res) {
  const data = req.body;
  const meta = foxxColl.save(req.body);
  res.send(Object.assign(data, meta));
});

// Retrieve an entry
router.get('/entries/:key', function (req, res) {
  try {
    const data = foxxColl.document(req.pathParams.key);
    res.send(data)
  } catch (e) {
    if (!e.isArangoError || e.errorNum !== DOC_NOT_FOUND) {
      throw e;
    }
    res.throw(404, 'The entry does not exist', e);
  }
});
```

Because the key will be automatically generated by ArangoDB when one wasn't specified in the request body, we're using `Object.assign` to apply the attributes of the metadata object returned by the `save` method to the document before returning it from our route.

The document method returns a document in a collection by its `_key` or `_id`. However when no matching document exists it throws an `ArangoError` exception. Because we want to provide a more descriptive error message than ArangoDB does out of the box, we need to handle that error explicitly.
